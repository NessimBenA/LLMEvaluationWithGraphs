#!/usr/bin/env python3
import json
import sys
import argparse
import os
import graphviz # Use the graphviz library
import re
DEFAULT_ENGINE = 'fdp' # Or 'fdp'
DEFAULT_FORMAT = 'svg'

# --- neato/fdp Attributes for Dense Edges Avoiding Nodes ---
GRAPH_ATTR = {
    # Removed rankdir - neato/fdp don't use it
    'splines': 'curved',
    'overlap': 'prism',   # Use a sophisticated overlap removal algorithm (or vpsc, ipsep)
    # 'nodesep'/'ranksep' are less relevant; control density via K/forces/sep
    'pad': '0.5',
    'dpi': '300',
    'bgcolor': '#fdfcf8',
    'fontname': 'Helvetica',
    'fontsize': '18',
    'outputorder': 'edgesfirst', # Still potentially useful

    # --- KEY ATTRIBUTES FOR neato/fdp ---
    'esep': '15',         # Margin for edge routing (KEEP THIS)
    'sep': '+15,+15',     # Margin for node overlap removal (try values like +10 to +20)
                          # Creates space between nodes after layout
    # 'K': 0.6,           # Optional (fdp/neato): Controls ideal edge length/spring strength. Lower might mean denser. Experiment.
    # 'repulsiveforce': 1.5, # Optional (sfdp): Adjust repulsion
}
NODE_ATTR = {
    'shape': 'box',
    'style': 'filled',
    'fillcolor': '#f5f5dc',
    'color': '#5d4037',
    'penwidth': '1.5',
    'fontname': 'Helvetica',
    'fontsize': '11',
    'fontcolor': '#4e342e',
}
EDGE_ATTR = {
    'color': '#8d6e63A0',  # Keep edge transparency
    'penwidth': '1.0',     # Keep thinner edges
    'arrowsize': '0.7',
    # 'len': 1.5,          # Optional (neato/fdp): Suggest ideal edge length. Experiment.
    'fontsize': '9',
    'fontname': 'Helvetica',
    'fontcolor': '#8d6e63',
}
TITLE_FONT_SIZE = '18'

# --- End Configuration ---


def sanitize(s):
    """Escape quotes/backslashes/newlines for DOT labels."""
    if s is None: return ""
    return str(s).replace("\\", "\\\\").replace('"', '\\"').replace('\n', '\\n')

def get_title_from_filename(filename):
    """Attempts to extract Concept and Model from standardized filename for title."""
    prefix = "standardized_"
    retry_match = re.search(r"_retry_(\d+)\.json$", filename)
    if not retry_match or not filename.startswith(prefix):
        return os.path.splitext(filename)[0].replace('_', ' ').strip()

    retry = int(retry_match.group(1))
    suffix = f"_retry_{retry}.json"
    core_part = filename[len(prefix):-len(suffix)]

    try:
        concept_raw, model = core_part.rsplit('_', 1)
        concept = concept_raw.replace('_', ' ').strip()
        return f"Knowledge Graph for '{concept}'\\nGenerated by: {model}"
    except ValueError:
        return core_part.replace('_', ' ')


def json_to_dot(data, graph_title, cluster_by_type=False):
    """Convert JSON to DOT string attempting edge overlap between nodes."""
    nodes = data.get("nodes", [])
    edges = data.get("edges", [])
    lines = ['digraph G {']

    # Apply Graph Attributes
    lines.append('  graph [')
    for key, value in GRAPH_ATTR.items(): lines.append(f'    {key}="{value}",')
    lines.append(f'    label="{sanitize(graph_title)}",')
    lines.append(f'    fontsize="{TITLE_FONT_SIZE}"')
    if lines[-1].endswith(','): lines[-1] = lines[-1][:-1]
    lines.append('  ];')
    lines.append('')

    # Apply Default Node Attributes
    lines.append('  node [')
    for key, value in NODE_ATTR.items(): lines.append(f'    {key}="{value}",')
    if lines[-1].endswith(','): lines[-1] = lines[-1][:-1]
    lines.append('  ];')
    lines.append('')

    # Apply Default Edge Attributes
    lines.append('  edge [')
    for key, value in EDGE_ATTR.items(): lines.append(f'    {key}="{value}",')
    if lines[-1].endswith(','): lines[-1] = lines[-1][:-1]
    lines.append('  ];')
    lines.append('')

    # Node Definitions
    node_id_set = {n.get("id") for n in nodes if n.get("id")}
    if cluster_by_type:
        by_type = {}
        for n in nodes:
            node_id = n.get("id")
            if not node_id: continue
            t = str(n.get("type", "__none__")).strip() or "__none__"
            by_type.setdefault(t, []).append(n)

        cluster_count = 0
        for t, group in by_type.items():
            if t == "__none__": continue
            cluster_label = sanitize(t)
            sanitized_type_name = re.sub(r'\W|^(?=\d)', '_', t)
            cluster_id = f"cluster_{cluster_count}_{sanitized_type_name}"
            cluster_count += 1

            lines.append(f'  subgraph "{cluster_id}" {{')
            lines.append(f'    label="{cluster_label}";')
            lines.append('    style="filled";')
            lines.append('    color="#eeeeee";')
            main_bg = GRAPH_ATTR.get("bgcolor", "#ffffff")
            bg_alpha = "90"
            lines.append(f'   bgcolor="{main_bg[:7]}{bg_alpha}";')
            lines.append('    fontname="Helvetica";')
            lines.append('    fontsize="10";')
            lines.append('    penwidth="1.0";')

            for n in group:
                nid = n.get("id")
                lbl = sanitize(n.get("label", nid))
                lines.append(f'    "{sanitize(nid)}" [label="{lbl}"];')
            lines.append('  }')
            lines.append('')

        for n in by_type.get("__none__", []):
            nid = n.get("id")
            lbl = sanitize(n.get("label", nid))
            lines.append(f'  "{sanitize(nid)}" [label="{lbl}"];')
    else:
        for n in nodes:
            nid = n.get("id", "__missing_id__")
            lbl = sanitize(n.get("label", nid))
            lines.append(f'  "{sanitize(nid)}" [label="{lbl}"];')

    lines.append('')
    # Edge Definitions
    valid_edge_count = 0
    skipped_edge_count = 0
    for e in edges:
        s, t = e.get("source"), e.get("target")
        if not s or not t or s not in node_id_set or t not in node_id_set:
            skipped_edge_count += 1
            continue

        lbl = sanitize(e.get("label",""))
        s_sanitized, t_sanitized = sanitize(s), sanitize(t)
        edge_attrs = [f'label="{lbl}"'] if lbl else []

        lines.append(f'  "{s_sanitized}" -> "{t_sanitized}"' + (f' [{", ".join(edge_attrs)}];' if edge_attrs else ';'))
        valid_edge_count +=1

    lines.append('}')
    return "\n".join(lines), valid_edge_count, skipped_edge_count

# --- Main Execution ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert standardized KG JSON files to aesthetic Graphviz images ('dot' engine, LR, warm, dense edges avoiding nodes)."
    )
    # (Arguments parsing remains the same)
    parser.add_argument("input_dir", help="Input directory containing standardized JSON graph files.")
    parser.add_argument("output_dir", help="Output directory to save the graph images.")
    parser.add_argument("-c", "--cluster", action="store_true",
                       help="Cluster nodes by their 'type' attribute.")
    parser.add_argument("-fmt", "--format", default=DEFAULT_FORMAT,
                        choices=['png', 'svg', 'pdf', 'jpg', 'gif'],
                        help=f"Output image format. Default: {DEFAULT_FORMAT}.")
    parser.add_argument("-f", "--force", action="store_true",
                       help="Overwrite existing output image files.")
    parser.add_argument("--skip_errors", action="store_true",
                       help="Continue processing other files if one fails.")

    args = parser.parse_args()

    # --- Path Validation ---
    if not os.path.isdir(args.input_dir):
        print(f"Error: Input directory not found: {args.input_dir}", file=sys.stderr); sys.exit(1)
    if not os.path.exists(args.output_dir):
        try: os.makedirs(args.output_dir); print(f"Created output directory: {args.output_dir}")
        except Exception as e: print(f"Error creating output directory '{args.output_dir}': {e}", file=sys.stderr); sys.exit(1)
    elif not os.path.isdir(args.output_dir):
         print(f"Error: Output path '{args.output_dir}' exists but is not a directory.", file=sys.stderr); sys.exit(1)

    # --- File Processing ---
    files_processed, files_failed, files_skipped_exist = 0, 0, 0
    graphviz_error_shown = False
    print(f"Processing JSON files from '{args.input_dir}' -> .{args.format} images in '{args.output_dir}' (Engine: dot, Style: LR Warm Dense Edges Avoid Nodes)...")
    print(f"Clustering: {'Yes' if args.cluster else 'No'}")

    for filename in sorted(os.listdir(args.input_dir)):
        if filename.lower().endswith(".json") and filename.startswith("standardized_"):
            # (File processing logic remains the same)
            input_filepath = os.path.join(args.input_dir, filename)
            base_name = os.path.splitext(filename)[0]
            output_base_name = base_name[len("standardized_"):] if base_name.startswith("standardized_") else base_name
            output_filepath_base = os.path.join(args.output_dir, output_base_name)
            output_image_path = f"{output_filepath_base}.{args.format}"

            print(f"\nProcessing: {filename} -> {os.path.basename(output_image_path)}...")

            if os.path.exists(output_image_path) and not args.force:
                print(f"  Skipping: Output file exists. Use -f to overwrite."); files_skipped_exist += 1; continue

            try:
                with open(input_filepath, encoding="utf-8") as f: data = json.load(f)
                if not data.get("nodes") and not data.get("edges"):
                    print("  Warning: Input JSON empty. Skipping."); files_processed += 1; continue

                graph_title = get_title_from_filename(filename)
                dot_string, edge_count, skipped_edges = json_to_dot(data, graph_title, cluster_by_type=args.cluster)

                if skipped_edges > 0: print(f"  Info: Skipped {skipped_edges} edges (missing nodes).")
                if edge_count == 0 and len(data.get('edges',[])) > 0: print("  Warning: All edges skipped or graph has only nodes.")

                graph_source = graphviz.Source(dot_string, engine='dot', format=args.format)
                rendered_path = graph_source.render(filename=output_filepath_base, view=False, cleanup=True)
                print(f"  Success: Saved image to '{os.path.basename(rendered_path)}'")
                files_processed += 1

            except json.JSONDecodeError as e: print(f"  ERROR: JSON decode failed for {filename}: {e}", file=sys.stderr); files_failed += 1;
            except graphviz.backend.execute.ExecutableNotFound:
                 if not graphviz_error_shown: print("\n--- GRAPHVIZ ERROR ---\n'dot' executable not found. Ensure Graphviz is installed and in PATH.\nSee: https://graphviz.org/download/\n----------------------", file=sys.stderr); graphviz_error_shown = True
                 files_failed += 1; break
            except Exception as e:
                print(f"  ERROR: Unexpected error processing {filename}: {e}", file=sys.stderr); import traceback; traceback.print_exc(file=sys.stderr); files_failed += 1;
                if not args.skip_errors: break


    # --- Summary ---
    # (Summary printing remains the same)
    print("\n--- Batch Processing Summary ---")
    print(f"Successfully processed: {files_processed} files")
    if files_skipped_exist > 0: print(f"Skipped (already exist): {files_skipped_exist} files")
    print(f"Failed:                 {files_failed} files")
    print("------------------------------")
    if graphviz_error_shown: sys.exit("Processing stopped due to missing Graphviz.")
    elif files_failed > 0 and not args.skip_errors: sys.exit("Processing stopped due to errors.")
    elif files_failed > 0: print("Completed with errors.")
    else: print("Completed successfully.")